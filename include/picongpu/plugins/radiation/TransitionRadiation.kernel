#pragma once

#include <string>
#include <iostream>
#include <fstream>
#include <cstdlib>

#include "picongpu/simulation_defines.hpp"
#include "picongpu/plugins/radiation/TransRadParticle.hpp"
#include "picongpu/plugins/radiation/TransRadCalculator.hpp"

#include <pmacc/dimensions/DataSpaceOperations.hpp>
#include <pmacc/mappings/kernel/AreaMapping.hpp>


namespace picongpu
{
    template<
        uint32_t T_numWorkers
    >
    struct KernelTransRadParticles
    {
        template<
            typename T_ParBox,
            typename T_DBox,
            typename T_DBoxComplex, // Formfactor returns complex values
            typename T_Mapping,
            typename T_Acc
        >
        DINLINE
        void operator( )(
            T_Acc const & acc,
            T_ParBox pb,
            T_DBox incTransRad,
            T_DBoxComplex cohTransRadPara,
            T_DBoxComplex cohTransRadPerp,
            T_DBox numParticles,
            DataSpace< simDim > globalOffset,
            T_Mapping mapper,
            radiation_frequencies::FreqFunctor freqFkt,
            DataSpace< simDim > simBoxSize
        ) const
        {
            using namespace mappings::threads;
            using complex_X = pmacc::math::Complex< float_X >;
            namespace po = boost::program_options;

            constexpr uint32_t frameSize = pmacc::math::CT::volume< SuperCellSize >::type::value;
            constexpr uint32_t numWorker = T_numWorkers;

            using FrameType = typename T_ParBox::FrameType;
            using FramePtr = typename T_ParBox::FramePtr;

            uint32_t const workerIdx = threadIdx.x;

            /* parallelized in 2 dimensions:
            * looking direction (theta, phi)
            * (not anymore data handling)
            * create shared memory for particle data to reduce global memory calls
            * every thread in a block loads one particle and every thread runs
            * through all particles and calculates the radiation for one direction
            * for all frequencies
            */
            constexpr int blockSize = pmacc::math::CT::volume< SuperCellSize >::type::value;

            // perpendicular part of normalized energy
            PMACC_SMEM( acc, energyPerp_s, memory::Array< float_X, blockSize > );

            // parallel part of normalized energy
            PMACC_SMEM( acc, energyPara_s, memory::Array< float_X, blockSize > );

            // amount of particles
            PMACC_SMEM( acc, num_s, memory::Array< float_X, blockSize > );

            // exponent of the form factor
            PMACC_SMEM( acc, formfactorExponent_s, memory::Array< complex_X, blockSize > );

            // storage for macro particle weighting needed if
            // the coherent and incoherent radiation of a single
            // macro-particle needs to be considered
            PMACC_SMEM( acc, radWeighting_s, memory::Array< float_X, blockSize > );

            // particle counter used if not all particles are considered for
            // radiation calculation
            PMACC_SMEM( acc, counter_s, int );
 

            int const theta_idx = blockIdx.x; //blockIdx.x is used to determine theta

            // looking direction (needed for observer) used in the thread
            float3_X const look = radiation_observer::observation_direction_picongpustandard( theta_idx );

            // get extent of guarding super cells (needed to ignore them)
            DataSpace< simDim > const guardingSuperCells = mapper.getGuardingSuperCells( );

            /* number of super cells on GPU per dimension (still including guard cells)
            * remove both guards from count [later one sided guard needs to be added again]
            */
            DataSpace< simDim > const superCellsCount( mapper.getGridSuperCells( ) - 2 * guardingSuperCells );

            // get absolute number of relevant super cells
            int const numSuperCells = superCellsCount.productOfComponents( );


            /* go over all super cells on GPU
            * but ignore all guarding supercells
            */
            for( int superCellIndex = 0; superCellIndex <= numSuperCells; ++superCellIndex )
            {
                // select SuperCell and add one sided guard again
                DataSpace< simDim > const superCell = DataSpaceOperations<simDim>::map(
                    superCellsCount,
                    superCellIndex
                ) + guardingSuperCells;
                    

                // -guardingSuperCells remove guarding block
                DataSpace< simDim > const superCellOffset(
                    globalOffset + (
                        ( superCell - guardingSuperCells ) *
                        SuperCellSize::toRT( )
                    )
                );

                // pointer to  frame storing particles
                FramePtr frame = pb.getLastFrame( superCell );

                // number  of particles in current frame
                lcellId_t particlesInFrame = pb.getSuperCell( superCell ).getSizeLastFrame( );

                /* go to next supercell
                *
                * if "isValid" is false then there is no frame
                * inside the superCell (anymore)
                */
                while( frame.isValid( ) )
                {
                    /* since a race condition can occur if "continue loop" is called,
                    *  all threads must wait for the selection of a new frame
                    *  until all threads have evaluated "isValid"
                    */
                    __syncthreads( );

                    ForEachIdx<
                        IdxConfig<
                            1,
                            numWorker
                        >
                    > onlyMaster{ workerIdx };

                    /* The Master process (thread 0) in every thread block is in
                    * charge of loading a frame from
                    * the current super cell and evaluate the total number of
                    * particles in this frame.
                    */
                    onlyMaster(
                        [&](
                            uint32_t const,
                            uint32_t const
                        )
                        {
                            counter_s = 0;
                        }
                    );

                    __syncthreads( );

                    using ParticleDomCfg = IdxConfig<
                        frameSize,
                        numWorker
                    >;

                    // loop over all particles in the frame
                    ForEachIdx< ParticleDomCfg > forEachParticle{ workerIdx };

                    forEachParticle(
                        [&](
                            uint32_t const linearIdx,
                            uint32_t const
                        )
                        {
                            // only threads with particles are running
                            if( linearIdx < particlesInFrame )
                            {
                                auto par = frame[ linearIdx ];
                                // get particle momenta
                                float3_X const particle_momentum = par[ momentum_ ];
                                /* initializes "saveParticleAt" flag with -1
                                * because "counter_s" will never be -1
                                * therefore, if a particle is saved, a value of counter
                                * is stored in "saveParticleAt" != -1
                                * THIS IS ACTUALLY ONLY NEEDED IF: the radiation flag was set
                                * LATER: can this be optimized?
                                */

                                int saveParticleAt = -1;

                                // only moving particles create transition radiation
                                if( ( particle_momentum * particle_momentum ).sumOfComponents( ) > 0.0)
                                {
                                    if( getRadiationMask( par ) )
                                        saveParticleAt = nvidia::atomicAllInc(
                                            acc,
                                            &counter_s,
                                            ::alpaka::hierarchy::Threads{ }
                                        );

                                    /* for information:
                                    *   atomicAdd returns an int with the previous
                                    *   value of "counter_s" != -1
                                    *   therefore, if a particle is selected
                                    *   "saveParticleAs" != -1
                                    */
                                    // if a particle needs to be considered
                                    if( saveParticleAt != -1 )
                                    {
                                        // calculate global position
                                        lcellId_t const cellIdx = par[ localCellIdx_ ];

                                        // position inside of the cell
                                        floatD_X const pos = par[ position_ ];

                                        // calculate global position of cell
                                        DataSpace< simDim > const globalPos(
                                            superCellOffset +
                                            DataSpaceOperations< simDim >::
                                                template map< SuperCellSize >( cellIdx )
                                        );

                                        // add global position of cell with local position of particle in cell
                                        float3_X particle_location;
                                        // set z component to zero in case of simDim==DIM2
                                        particle_location[ 2 ] = 0.0;
                                        // run over all components and compute gobal position
                                        for( int i = 0; i < simDim; ++i )
                                            particle_location[ i ] = ( 
                                                float_X( globalPos[ i ] ) + pos[ i ] 
                                            ) * cellSize[ i ];

                                        /* get macro-particle weighting
                                        *
                                        * Info:
                                        * the weighting is the number of real particles described
                                        * by a macro-particle
                                        */
                                        float_X const weighting = par[ weighting_ ];
                                        radWeighting_s[ saveParticleAt ] = weighting;

                                        // mass of macro-particle
                                        float_X const particle_mass = attribute::getMass(
                                            weighting,
                                            par
                                        );

                                        // charge of macro-particle
                                        float_X const particle_charge = attribute::getCharge(
                                            weighting,
                                            par
                                        );

                                        // using transition radiation particle class
                                        transitionRadiation::Particle const particle(
                                            particle_location,
                                            particle_momentum,
                                            particle_charge,
                                            particle_mass
                                        );

                                        // create calculator for TR calculations
                                        TransRadCalculator const calculator =  TransRadCalculator(
                                            particle,
                                            look
                                        );

                                        // calculate values for transition radiation
                                        energyPara_s[ saveParticleAt ] = calculator.calcEPara( );

                                        energyPerp_s[ saveParticleAt ] = calculator.calcEPerp( );

                                        formfactorExponent_s[ saveParticleAt ] = calculator.calcFExponent( );

                                        num_s[ saveParticleAt ] = weighting;
                                    }
                                } // only moving particles
                            } // only threads with particle
                        } 
                    ); // for each particle
                    __syncthreads( );

                    // run over all  valid omegas for this thread
                    for( int o = workerIdx; o < radiation_frequencies::N_omega; o += T_numWorkers )
                    {
                        float_X itrSum = 0.0;
                        float_X numParticlesAsdf = 0.0;
                        float_X totalParticles = 0.0;
                        complex_X ctrSumPara = complex_X( 0.0, 0.0 );
                        complex_X ctrSumPerp = complex_X( 0.0, 0.0 );

                        // create a form factor object
                        //radFormFactor::radFormFactor const myRadFormFactor{ };

                        for( int j = 0; j < counter_s; ++j )
                        {
                            picongpu::float_64 const omega = freqFkt( o );
                            complex_X const formfactor = makeExponentUseful(
                                omega, 
                                formfactorExponent_s[ j ]
                            );

                            // float_X const macroParticleFormFactor = myRadFormFactor(
                            //     radWeighting_s[ j ],
                            //     omega,
                            //     look
                            // );

                            // itrSum += energyPerp_s[ j ] * energyPerp_s[ j ] / ( num_s[ j ] * num_s[ j ] ) + 
                            //     energyPara_s[ j ] * energyPara_s[ j ] / ( num_s[ j ] * num_s[ j ] );
                            // itrSum += energyPerp_s[ j ] * energyPerp_s[ j ] / ( totalParticles * totalParticles ) + 
                            //     energyPara_s[ j ] * energyPara_s[ j ] / ( totalParticles * totalParticles );

                            itrSum += radWeighting_s[j] * (energyPerp_s[ j ] * energyPerp_s[ j ] + 
                                energyPara_s[ j ] * energyPara_s[ j ]);
                            // itrSum += energyPerp_s[j] * energyPerp_s[j];
                            //itrSum *= macroParticleFormFactor * macroParticleFormFactor;
                            numParticlesAsdf += num_s[ j ];
                            totalParticles += num_s[ j ];
                            // ctrSumPara += energyPara_s[ j ] * formfactor / ( num_s[ j ] * num_s[ j ] );
                            // ctrSumPerp += energyPerp_s[ j ] * formfactor / ( num_s[ j ] * num_s[ j ] );
                            ctrSumPara += radWeighting_s[j] * energyPara_s[ j ] * formfactor;// / ( totalParticles );
                            ctrSumPerp += radWeighting_s[j] * energyPerp_s[ j ] * formfactor;// / ( totalParticles );
                            // ctrSumPara += energyPara_s[ j ] * formfactor;// / ( totalParticles );
                            // ctrSumPerp += energyPerp_s[ j ] * formfactor;
                            // if( num_s[ j ] < 1.0 )
                            // {
                            //     printf("num_s[ j ] is less than 1");
                            // } 
                        }


                        int const index = theta_idx * radiation_frequencies::N_omega + o;
                        incTransRad[ index ] += ( itrSum ); // / ( totalParticles );
                        numParticles[ index ] += totalParticles;
                        cohTransRadPara[ index ] += ( ctrSumPara ); // / math::sqrt( totalParticles );
                        cohTransRadPerp[ index ] += ( ctrSumPerp ); // / math::sqrt( totalParticles );

                        
                        // incTransRad[ index ]; // /= (totalParticles * totalParticles);
                        // cohTransRadPara[ index ]; // /= totalParticles;
                        // cohTransRadPerp[ index ]; // /= totalParticles;
                    
                    }

                    __syncthreads( );

                    /* First threads starts loading next frame of the super-cell:
                     *
                     * Info:
                     *   The calculation starts with the last SuperCell (must not be full filled)
                     *   all previous SuperCells are full with particles
                     */
                    particlesInFrame = frameSize;
                    frame = pb.getPreviousFrame( frame );
                } // while frame is valid
            } // for all supercells 

            //__syncthreads( );


            // ForEachIdx<
            //     IdxConfig<
            //         1,
            //         numWorker
            //     >
            // > onlyMaster{ workerIdx };

            // onlyMaster(
            //     [&](
            //         uint32_t const,
            //         uint32_t const
            //     )
            //     {
            // for( int o = workerIdx; o < radiation_frequencies::N_omega; o += T_numWorkers )
            // {
            //     int const index = theta_idx * radiation_frequencies::N_omega + o;
                
            //     if ( numParticles[ index ] == 0 )
            //     {
            //         incTransRad[ index ] = 0;
            //     }
            //     else
            //     {
            //         const float_X tmpinctransrad  = incTransRad[ index ];
            //         incTransRad[ index ] = 0.0;

            //         incTransRad[ index ] += 
            //         (
            //             tmpinctransrad  
            //             + 
            //             ( numParticles[ index ] - 1.0 )
            //             * 
            //             ( 
            //                 math::abs2( cohTransRadPara[ index ] ) 
            //                 + math::abs2( cohTransRadPerp[ index ] ) 
            //             )
            //             / 
            //             ( numParticles[ index ] )
            //         );
            //     }
            //     cohTransRadPara[ index ] = 1.0;
            //     cohTransRadPerp[ index ] = 1.0;
            //     numParticles[ index ] = 0.0;            
            // }
            //     }
            // );
            

            //__syncthreads( );
        }
    }; // struct KernelTransRad
} // namespace picongpu
