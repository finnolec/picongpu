#pragma once

#include <string>
#include <iostream>
#include <fstream>
#include <cstdlib>

#include "picongpu/simulation_defines.hpp"
#include "picongpu/plugins/radiation/CoolParticle.hpp"
#include "picongpu/plugins/radiation/TransRadCalculator.hpp"

#include <pmacc/dimensions/DataSpaceOperations.hpp>
#include <pmacc/mappings/kernel/AreaMapping.hpp>

namespace picongpu
{
    template<
        uint32_t T_numWorkers
    >
    struct KernelTransRadParticles
    {
        template<
            typename ParBox,
            typename DBox,
            typename Mapping,
            typename T_Acc
        >
        DINLINE
        void operator()(
            T_Acc const & acc,
            ParBox pb,
            DBox incTransRad,
            DBox numParticles,
            DataSpace<simDim> globalOffset,
            Mapping mapper,
            radiation_frequencies::FreqFunctor freqFkt,
            DataSpace<simDim> simBoxSize
        ) const
        {
            using namespace mappings::threads;
            namespace po = boost::program_options;

            constexpr uint32_t frameSize = pmacc::math::CT::volume< SuperCellSize >::type::value;
            constexpr uint32_t numWorker = T_numWorkers;

            using FrameType = typename ParBox::FrameType;
            using FramePtr = typename ParBox::FramePtr;

            uint32_t const workerIdx = threadIdx.x;

            /// calculate radiated Amplitude
            /* parallelized in 1 dimensions:
            * looking direction (theta)
            * (not anymore data handling)
            * create shared memory for particle data to reduce global memory calls
            * every thread in a block loads one particle and every thread runs
            * through all particles and calculates the radiation for one direction
            * for all frequencies
            */
            constexpr int blockSize = pmacc::math::CT::volume<SuperCellSize>::type::value;

            // perpendicular part of normalized energy
            PMACC_SMEM( acc, energy_perp_s, memory::Array<picongpu::float_X, blockSize > );

            // parallel part of normalized energy
            PMACC_SMEM( acc, energy_para_s, memory::Array<picongpu::float_X, blockSize> );

            // amount of particles
            PMACC_SMEM( acc, num_s, memory::Array< picongpu::float_X, blockSize > );
            // storage for macro particle weighting needed if
            // the coherent and incoherent radiation of a single
            // macro-particle needs to be considered
            PMACC_SMEM( acc, radWeighting_s, memory::Array< float_X, blockSize > );


            PMACC_SMEM( acc, counter_s, int );
 

            int const theta_idx = blockIdx.x; //blockIdx.x is used to determine theta

            // looking direction (needed for observer) used in the thread
            float3_X const look = radiation_observer::observation_direction_picongpustandard( theta_idx );

            // get extent of guarding super cells (needed to ignore them)
            DataSpace< simDim > const guardingSuperCells = mapper.getGuardingSuperCells();

            /* number of super cells on GPU per dimension (still including guard cells)
            * remove both guards from count [later one sided guard needs to be added again]
            */
            DataSpace< simDim > const superCellsCount( mapper.getGridSuperCells( ) - 2 * guardingSuperCells );

            // get absolute number of relevant super cells
            int const numSuperCells = superCellsCount.productOfComponents();


            /* go over all super cells on GPU
            * but ignore all guarding supercells
            */
            for( int super_cell_index = 0; super_cell_index <= numSuperCells; ++super_cell_index )
            {
                // select SuperCell and add one sided guard again
                DataSpace< simDim > const superCell = DataSpaceOperations<simDim>::map(
                    superCellsCount,
                    super_cell_index
                ) + guardingSuperCells;
                    

                // -guardingSuperCells remove guarding block
                DataSpace< simDim > const superCellOffset(
                    globalOffset +
                    (
                        ( superCell - guardingSuperCells ) *
                        SuperCellSize::toRT()
                    )
                );

                // pointer to  frame storing particles
                FramePtr frame = pb.getLastFrame( superCell );

                // number  of particles in current frame
                lcellId_t particlesInFrame = pb.getSuperCell( superCell ).getSizeLastFrame();

                /* go to next supercell
                *
                * if "isValid" is false then there is no frame
                * inside the superCell (anymore)
                */
                while( frame.isValid() )
                {
                    /* since a race condition can occur if "continue loop" is called,
                    *  all threads must wait for the selection of a new frame
                    *  until all threads have evaluated "isValid"
                    */
                    __syncthreads();

                    ForEachIdx<
                        IdxConfig<
                            1,
                            numWorker
                        >
                    > onlyMaster{ workerIdx };

                    /* The Master process (thread 0) in every thread block is in
                    * charge of loading a frame from
                    * the current super cell and evaluate the total number of
                    * particles in this frame.
                    */
                    onlyMaster(
                        [&](
                            uint32_t const,
                            uint32_t const
                        )
                        {
                            counter_s = 0;
                        }
                    );

                    __syncthreads();

                    using ParticleDomCfg = IdxConfig<
                        frameSize,
                        numWorker
                    >;

                    // loop over all particles in the frame
                    ForEachIdx< ParticleDomCfg > forEachParticle{ workerIdx };

                    forEachParticle(
                        [&](
                            uint32_t const linearIdx,
                            uint32_t const
                        )
                        {
                            // only threads with particles are running
                            if( linearIdx < particlesInFrame )
                            {
                                auto par = frame[ linearIdx ];
                                // get particle momenta
                                float3_X const particle_momentum = par[momentum_];
                                /* initializes "saveParticleAt" flag with -1
                                * because "counter_s" will never be -1
                                * therefore, if a particle is saved, a value of counter
                                * is stored in "saveParticleAt" != -1
                                * THIS IS ACTUALLY ONLY NEEDED IF: the radiation flag was set
                                * LATER: can this be optimized?
                                */

                                int saveParticleAt = -1;

                                // only moving particles create transition radiation
                                if( (particle_momentum*particle_momentum).sumOfComponents() > 0.0)
                                {
                                    if( getRadiationMask(par) )
                                        saveParticleAt = nvidia::atomicAllInc(
                                            acc,
                                            &counter_s,
                                            ::alpaka::hierarchy::Threads{}
                                        );

                                    /* for information:
                                    *   atomicAdd returns an int with the previous
                                    *   value of "counter_s" != -1
                                    *   therefore, if a particle is selected
                                    *   "saveParticleAs" != -1
                                    */
                                    // if a particle needs to be considered
                                    if( saveParticleAt != -1 )
                                    {
                                        // calculate global position
                                        lcellId_t const cellIdx = par[ localCellIdx_ ];

                                        // position inside of the cell
                                        floatD_X const pos = par[ position_ ];

                                        // calculate global position of cell
                                        DataSpace< simDim > const globalPos(
                                            superCellOffset +
                                            DataSpaceOperations< simDim >::
                                                template map< SuperCellSize >( cellIdx )
                                        );

                                        // add global position of cell with local position of particle in cell
                                        float3_X particle_location;
                                        // set z component to zero in case of simDim==DIM2
                                        particle_location[ 2 ] = 0.0;
                                        // run over all components and compute gobal position
                                        for( int i = 0; i < simDim; ++i )
                                            particle_location[ i ] = ( float_X( globalPos[ i ] ) + pos[ i ] ) * cellSize[ i ];

                                        /* get macro-particle weighting
                                            *
                                            * Info:
                                            * the weighting is the number of real particles described
                                            * by a macro-particle
                                            */
                                        float_X const weighting = par[ weighting_ ];
                                        radWeighting_s[ saveParticleAt ] = weighting;

                                        // mass of macro-particle
                                        float_X const particle_mass = attribute::getMass(
                                            weighting,
                                            par
                                        );

                                        // charge of macro-particle
                                        float_X const particle_charge = attribute::getCharge(
                                            weighting,
                                            par
                                        );

                                        //printf("Particle Momentum: %f \tparticle charge: %f \tparticle mass %f\n", particle_momentum * particle_momentum, particle_charge, particle_mass);
                                        //printf("mom x: %.15f, mom y: %.15f, mom z: %.15f\n", particle_momentum.x(), particle_momentum.y(), particle_momentum.z());
                                        // using transition radiation particle class
                                        // printf("shuut shuut \n");
                                        CoolParticle const particle(
                                            particle_location,
                                            particle_momentum,
                                            particle_charge,
                                            particle_mass
                                        );

                                        // create calculator for TR calculations
                                        TransRadCalculator const calculator =  TransRadCalculator(
                                            particle,
                                            look
                                        );

                                        // calculate values for transition radiation
                                        energy_perp_s[ saveParticleAt ] = calculator.calcEPerp();

                                        energy_para_s[ saveParticleAt ] = calculator.calcEPara();

                                        num_s[ saveParticleAt ] = weighting;
                                    }
                                } // only moving particles
                            } // only threads with particle
                        } 
                    ); // for each particle
                    __syncthreads();

                    // run over all  valid omegas for this thread
                    for( int o = workerIdx; o < radiation_frequencies::N_omega; o += T_numWorkers )
                    {
                        picongpu::float_X itrSum;
                        picongpu::float_X numParticlesAsdf;

                        itrSum = 0.0;
                        numParticlesAsdf = 0.0;
 
                        for( int j = 0; j < counter_s; ++j )
                        {
                            itrSum += energy_perp_s[j] * energy_perp_s[j] + energy_para_s[j] * energy_para_s[j];
                            numParticlesAsdf += num_s[j];
                            //printf("itr_sum = %.15f", itrSum);
                        }

                        const int index = theta_idx * radiation_frequencies::N_omega + o;
                        incTransRad[ index ] += itrSum;
                        numParticles[ index ] += numParticlesAsdf;
                    }

                    __syncthreads();

                    /* First threads starts loading next frame of the super-cell:
                     *
                     * Info:
                     *   The calculation starts with the last SuperCell (must not be full filled)
                     *   all previous SuperCells are full with particles
                     */
                    particlesInFrame = frameSize;
                    frame = pb.getPreviousFrame( frame );
                } // while frame is valid
            } // for all supercells 

        }
    }; // struct KernelTransRad
} // namespace picongpu
